/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2023-02-24
******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include <stdio.h>

#include "i2c.h"
#include "iwdg.h"
#include "modbus_rtu.h"
#include "sgp30.h"
#include "sysclock_config.h"
#include "usart_config.h"
#include "utils.h"

/* Private typedef */
/* Private define  */
#define DEBUG_CONSOLE_EN 1

#define DBUG_MSG_LEN     100

uint16_t rFlag = 0;  // Modbus RTU register flag
#define RFLAG_CO2         (uint16_t)0x01
#define RFLAG_TVOC        (uint16_t)0x02
#define RFLAG_BASE_CO2    (uint16_t)0x04
#define RFLAG_BASE_TVOC   (uint16_t)0x08
#define RFLAG_RAW_H2      (uint16_t)0x10
#define RFLAG_RAW_ETHANOL (uint16_t)0x20
#define RFLAG_FEATURE_SET (uint16_t)0x40
#define RFLAG_SERIAL_ID   (uint16_t)0x80

int32_t u1tcFlag = 0;  // USART1 Transmite complete flag
#define TRUE  (int32_t)1
#define FALSE (int32_t)0

/* Private macro */
#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))

/* Private variables */
uint8_t usart1_rx_dma_buffer[USART1_RX_DMA_BUFFER_SIZE];
char    usart2_rx_dma_buffer[USART2_RX_DMA_BUFFER_SIZE];
sgp30_t sgp_data;

/* Private function prototypes */
void               modbusRtu_SendData(const uint8_t *const data, const size_t data_length);
MODBUS_RTU_ERR     modbusRtu_ReadInputRegister(const uint8_t *const modbus_rtu_frame, void *data,
                                               uint8_t *reply_data, uint8_t *reply_data_len);
static inline void LED2_init(void);
/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void) {
    __disable_irq();

    /* Configure the system clock to 32 MHz and update SystemCoreClock */
    SetSysClock();
    SystemCoreClockUpdate();

    /* TODO - Add your application code here */
    USART1_dma_init();
    USART2_dma_init();
    I2C1_init();
    IWDG_init();
    LED2_init();
    sgp_data = sgp30_create();

    int32_t  sgp30IsOnline      = FALSE;
    uint32_t setBaselineCounter = 0u;

#if (DEBUG_CONSOLE_EN > 0u)
    char debug_msg[DBUG_MSG_LEN];
    debug_console("App started...\n\r");
#endif
    if (SGP30_SUCCESS != sgp30_GetSerialId(&sgp_data)) {
        rFlag &= ~RFLAG_SERIAL_ID;
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("Error! sgp30_GetSerialId failed!\n\r");
#endif
    } else {
        sgp30IsOnline = TRUE;
        rFlag         |= RFLAG_SERIAL_ID;
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("sgp30_GetSerialId success!\n\r");
        snprintf(debug_msg, DBUG_MSG_LEN, "Serial ID:%#llx\n\r", sgp_data.serialID);
        debug_console(debug_msg);
#endif
    }

    if (sgp30IsOnline) {
        if (SGP30_SUCCESS != sgp30_GetFeatureSetVersion(&sgp_data)) {
            rFlag &= RFLAG_FEATURE_SET;
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console("Error! spg30_GetFeatureSetVersion failed!\n\r");
#endif
        } else {
            rFlag |= RFLAG_FEATURE_SET;
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console("spg30_GetFeatureSetVersion success!\n\r");
            snprintf(debug_msg, DBUG_MSG_LEN, "Feature set:%#x\n\r", sgp_data.featureSetVersion);
            debug_console(debug_msg);
#endif
        }
    }

    sgp30_InitAirQuality();
    __enable_irq();
    /* Infinite loop */
    while (1) {
        IWDG_feed();  // Feed watchdog

        rFlag &= ~(RFLAG_CO2 | RFLAG_TVOC | RFLAG_BASE_CO2 | RFLAG_BASE_TVOC | RFLAG_RAW_H2 |
                   RFLAG_RAW_ETHANOL);  // clear bits

        setBaselineCounter++;

        if (sgp30IsOnline) {
            // According to datasheet, SGP30 baseline values need to be set at about 1 hour interval
            if (setBaselineCounter >= 3600U) {
                if (SGP30_SUCCESS != spg30_GetBaseLine(&sgp_data)) {
#if (DEBUG_CONSOLE_EN > 0u)
                    debug_console("Error! spg30_GetBaseline failed!\n\r");
#endif
                    rFlag &= (RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
                } else {
#if (DEBUG_CONSOLE_EN > 0u)
                    debug_console("spg30_GetBaseline success!\n\r");
                    snprintf(debug_msg, DBUG_MSG_LEN, "baselineCO2:%uppm, baselineTVOC:%uppb\n\r",
                             sgp_data.baselineCO2, sgp_data.baselineTVOC);
                    debug_console(debug_msg);
#endif
                    rFlag |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
                    sgp30_SetBaseline(sgp_data.baselineCO2, sgp_data.baselineTVOC);
                }
                setBaselineCounter = 0;
            }

            // According to datasheet, SGP30 MeasureAirQuality need to be called at about 1s
            // interval in order to work at maximum accuracy
            if (SGP30_SUCCESS != sgp30_MeasureAirQuality(&sgp_data)) {
                rFlag &= ~(RFLAG_CO2 | RFLAG_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                debug_console("Error! spg30_MeasureAirQuality failed!\n\r");
#endif
            } else {
                rFlag |= (RFLAG_CO2 | RFLAG_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                debug_console("spg30_MeasureAirQuality success!\n\r");
                snprintf(debug_msg, DBUG_MSG_LEN, "CO2eq:%uppm\n\r", sgp_data.CO2);
                debug_console(debug_msg);
                snprintf(debug_msg, DBUG_MSG_LEN, "TVOC:%uppb\n\r", sgp_data.TVOC);
                debug_console(debug_msg);
#endif
            }
        } else {
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console("Error! SGP30 is offline!\n\r");
#endif
        }

        GPIOA->ODR ^= 0x20;  //  Blink led
        delay_ms(1000);
    }
    return 0;
}

/* Interrupt handlers here */

/**
 * \brief   DMA1 channel5 interrupt handler for USART1 RX
 * \author  Siyuan Xu,
 */
void DMA1_Channel5_IRQHandler(void) {
    /* Check half-transfer complete interrupt */
    if (DMA1->ISR & DMA_ISR_HTIF5) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART1 DMA half-transfer interrupt!\r\n");
#endif
        DMA1->IFCR |= DMA_IFCR_CHTIF5; /*!< Channel 5 Half Transfer clear */
    }

    /* Check transfer-complete interrupt */
    if (DMA1->ISR & DMA_ISR_TCIF5) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART1 DMA transfer-complete interrupt!\r\n");
#endif
        u1tcFlag   = TRUE;
        DMA1->IFCR |= DMA_IFCR_CTCIF5; /*!< Channel 5 Transfer Complete clear */
        if (MODBUS_RTU_SUCCESS !=
            modbusRtu_AddressValidation(usart1_rx_dma_buffer[SLAVE_ADDRESS])) {
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console("Not my address, discard the frame!\r\n");
#endif
        } else {
            modbusRtu_RunRequest(usart1_rx_dma_buffer, (void *)(&sgp_data));
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console("Not my address, discard the frame!\r\n");
#endif
        }
        USART1_RX_Buffer_Reset();
        DMA1_Channel15_Reload();
    }
}

/**
 * \brief   USART1 global interrupt handler
 * \author  Siyuan xu, e2101066@edu.vamk.fi, Feb.2023
 */
void USART1_IRQHandler(void) {
    uint32_t status = USART1->SR;
    uint8_t  data __attribute__((unused));
    /* Check for IDLE line interrupt */
    if (status & USART_SR_IDLE) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART1 Idle-line interrupt!\r\n");
#endif
        data = USART1->DR; /* Clear IDLE line flag */
        if (u1tcFlag == TRUE) {
            u1tcFlag = FALSE;
        } else {
            // Error condition when USART1 DMA transmit complete flag is false and IDLE line
            // interrupt fires, reset DMA1 and buffer
#if (DEBUG_CONSOLE_EN > 0u)
            debug_console(
                "Tranmition error!"
                "IDLE line detected, but transmition complete flag is FALSE!\n\r");
#endif
            USART1_RX_Buffer_Reset();
            DMA1_Channel15_Reload();
        }
    }
}

/**
 * \brief   DMA1 channel6 interrupt handler for USART2 RX
 * \author  Siyuan xu, e2101066@edu.vamk.fi, Feb.2023
 */
void DMA1_Channel6_IRQHandler(void) {
    /* Check half-transfer complete interrupt */
    if (DMA1->ISR & DMA_ISR_HTIF6) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART2 DMA half-transfer interrupt!\r\n");
#endif
        DMA1->IFCR |= DMA_IFCR_CHTIF6; /*!< Channel 6 Half Transfer clear */

        USART2_send_data(usart2_rx_dma_buffer, USART2_RX_DMA_BUFFER_SIZE);
    }

    /* Check transfer-complete interrupt */
    if (DMA1->ISR & DMA_ISR_TCIF6) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART2 DMA transfer-complete interrupt!\r\n");
#endif
        DMA1->IFCR |= DMA_IFCR_CTCIF6; /*!< Channel 6 Transfer Complete clear */
        USART2_send_data(usart2_rx_dma_buffer, USART2_RX_DMA_BUFFER_SIZE);
    }
}

/**
 * \brief   USART2 global interrupt handler
 * \author  Siyuan xu, e2101066@edu.vamk.fi, Feb.2023
 */
void USART2_IRQHandler(void) {
    uint32_t status = USART2->SR;
    uint8_t  data __attribute__((unused));
    /* Check for IDLE line interrupt */
    if (status & USART_SR_IDLE) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("USART2 Idle-line interrupt!\r\n");
#endif
        data = USART2->DR; /* Clear IDLE line flag */
        USART2_send_data(usart2_rx_dma_buffer, USART2_RX_DMA_BUFFER_SIZE);
        DMA1_Channel16_Reload();
    }
}

/* Private functions */
/**
 * \brief Initialize on-board LED2
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
static inline void LED2_init(void) {
    RCC->AHBENR  |= 1;      // GPIOA ABH bus clock ON. p154
    GPIOA->MODER |= 0x400;  // GPIOA pin 5 to output. p184
    GPIOA->ODR   ^= 0x20;
}

/**
 * \brief Local implementation for sending Modbus RTU data
 * \param[in] data - The address of the data to be sent
 * \param[in] data_length - The number of bytes
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
void modbusRtu_SendData(const uint8_t *const data, const size_t data_length) {
    rs485_send_data(data, data_length);
}

/**
 * \brief Local implementation for reading input register for Modbus RTU
 * \param[in] modbus_rtu_frame - Address + PDU + CRC, PDU = Function code + Data
 * \param[in] data - The address of the data to be sent, sgp30_t
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
MODBUS_RTU_ERR modbusRtu_ReadInputRegister(const uint8_t *const modbus_rtu_frame, void *data,
                                           uint8_t *reply_data, uint8_t *reply_data_len) {
    sgp30_t *sgp30_data    = (sgp30_t *)data;
    uint16_t register_addr = ((uint16_t)modbus_rtu_frame[START_ADDRESS_HI] << 8) |
                             (uint16_t)modbus_rtu_frame[START_ADDRESS_LOW];
    MODBUS_RTU_ERR err;
#if (DEBUG_CONSOLE_EN > 0u)
    char debug_msg[100];
#endif
    err = modbusRtu_RegisterAddressValidation(register_addr);
    if (err != MODBUS_RTU_SUCCESS) {
#if (DEBUG_CONSOLE_EN > 0u)
        debug_console("BAD REGISTER ADDR:");
#endif
    } else {
        switch (register_addr) {
            case REG_ADDR_CO2:
                if (rFlag & RFLAG_CO2) {
                    reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->CO2 >> 8);
                    reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->CO2 & 0xff);
                    *reply_data_len       = 2;
#if (DEBUG_CONSOLE_EN > 0u)
                    sprintf(debug_msg, "CO2eq:%u\n\r", sgp30_data->CO2);
                    debug_console(debug_msg);
#endif
                    err = MODBUS_RTU_SUCCESS;
                } else {
                    err = MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                }
                break;
            case REG_ADDR_TVOC:
                if (rFlag & RFLAG_TVOC) {
                    reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->TVOC >> 8);
                    reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->TVOC & 0xff);
                    *reply_data_len       = 2;
                    err                   = MODBUS_RTU_SUCCESS;
                } else {
                    err = MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                }
                break;
            case REG_ADDR_BASE_CO2:
                if (rFlag & RFLAG_BASE_TVOC) {
                    reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->baselineCO2 >> 8);
                    reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->baselineCO2 & 0xff);
                    *reply_data_len       = 2;
                    err                   = MODBUS_RTU_SUCCESS;
                } else {
                    if (SGP30_SUCCESS != spg30_GetBaseLine(sgp30_data)) {
                        rFlag &= ~(RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                        debug_console("Error! spg30_GetBaseline failed!\n\r");
#endif
                        err = MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                    } else {
                        reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->baselineCO2 >> 8);
                        reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->baselineCO2 & 0xff);
                        *reply_data_len       = 2;
                        rFlag                 |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                        debug_console("spg30_GetBaseline success!\n\r");
#endif
                        err = MODBUS_RTU_SUCCESS;
                    }
                }
                break;
            case REG_ADDR_BASE_TVOC:
                if (rFlag & RFLAG_BASE_TVOC) {
                    reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->baselineTVOC >> 8);
                    reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->baselineTVOC & 0xff);
                    *reply_data_len       = 2;
                    err                   = MODBUS_RTU_SUCCESS;
                } else {
                    if (SGP30_SUCCESS != spg30_GetBaseLine(sgp30_data)) {
                        rFlag &= ~(RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                        debug_console("Error! spg30_GetBaseline failed!\n\r");
#endif
                        err = MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                    } else {
                        reply_data[SGP30_MSB] = (uint8_t)(sgp30_data->baselineTVOC >> 8);
                        reply_data[SGP30_LSB] = (uint8_t)(sgp30_data->baselineTVOC & 0xff);
                        *reply_data_len       = 2;
                        rFlag                 |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVOC);
#if (DEBUG_CONSOLE_EN > 0u)
                        debug_console("spg30_GetBaseline success!\n\r");
#endif
                        err = MODBUS_RTU_SUCCESS;
                    }
                }
                break;
            case REG_ADDR_FEATURE_SET:
                err = MODBUS_RTU_SUCCESS;
                break;
            case REG_ADDR_RAW_H2:
                err = MODBUS_RTU_SUCCESS;
                break;
            case REG_ADDR_RAW_ETHANOL:
                err = MODBUS_RTU_SUCCESS;
                break;
            case REG_ADDR_SERIAL_ID:
                err = MODBUS_RTU_SUCCESS;
                break;
        }
    }
    return err;
}

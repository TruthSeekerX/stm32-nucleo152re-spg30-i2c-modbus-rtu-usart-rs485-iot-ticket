/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2023-02-24
******************************************************************************
*/

/* Includes */
#include <stddef.h>

#include "iwdg.h"
#include "modbus_rtu.h"
#include "sgp30.h"
#include "sysclock_config.h"
#include "usart_config.h"
#include "utils.h"

/* Private typedef */
/* Private define  */
#define DBUG_MSG_LEN 100

uint16_t rFlag = 0;  // Modbus RTU register flag
#define RFLAG_CO2         (uint16_t)0x01
#define RFLAG_TVCO        (uint16_t)0x02
#define RFLAG_BASE_CO2    (uint16_t)0x04
#define RFLAG_BASE_TVCO   (uint16_t)0x08
#define RFLAG_RAW_H2      (uint16_t)0x10
#define RFLAG_RAW_ETHANOL (uint16_t)0x20
#define RFLAG_FEATURE_SET (uint16_t)0x40
#define RFLAG_SERIAL_ID   (uint16_t)0x80

uint8_t u1tcFlag = 0;  // USART1 Transmite complete flag
#define TRUE  (uint8_t)1
#define FALSE (uint8_t)0

/* Private macro */
#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))

/* Private variables */
uint8_t usart1_rx_dma_buffer[USART1_RX_DMA_BUFFER_SIZE];
char    usart2_rx_dma_buffer[USART2_RX_DMA_BUFFER_SIZE];
sgp30_t sgp_data;

/* Private function prototypes */
void           debug_console(const char *message);
void           modbusRtu_SendData(const uint8_t *const data, const size_t data_length);
MODBUS_RTU_ERR modbusRtu_ReadInputRegister(const uint8_t *const modbus_rtu_frame, void *data);

/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void) {
    debug_console("App started...\n\r");
    __disable_irq();

    /* Configure the system clock to 32 MHz and update SystemCoreClock */
    SetSysClock();
    SystemCoreClockUpdate();

    /* TODO - Add your application code here */
    USART1_dma_init();
    USART2_dma_init();
    IWDG_init();
    sgp_data = sgp30_create();

    RCC->AHBENR  |= 1;      // GPIOA ABH bus clock ON. p154
    GPIOA->MODER |= 0x400;  // GPIOA pin 5 to output. p184
    GPIOA->ODR   ^= 0x20;

    char     debug_msg[DBUG_MSG_LEN];
    uint32_t setBaselineCounter = 0u;

    if (SGP30_SUCCESS != sgp30_GetSerialId(&sgp_data)) {
        rFlag &= ~RFLAG_SERIAL_ID;
        debug_console("Error! sgp30_GetSerialId failed!\n\r");
    } else {
        rFlag |= RFLAG_SERIAL_ID;
        debug_console("sgp30_GetSerialId success!\n\r");
        snprintf(debug_msg, DBUG_MSG_LEN, "Serial ID:%#lx\n\r", sgp_data.serialID);
        debug_console(debug_msg);
    }

    if (SGP30_SUCCESS != sgp30_GetFeatureSetVersion(&sgp_data)) {
        rFlag &= RFLAG_FEATURE_SET;
        debug_console("Error! spg30_GetFeatureSetVersion failed!\n\r");
    } else {
        rFlag |= RFLAG_FEATURE_SET;
        debug_console("spg30_GetFeatureSetVersion success!\n\r");
        snprintf(debug_msg, DBUG_MSG_LEN, "Feature set:%#x\n\r", sgp_data.featureSetVersion);
        debug_console(debug_msg);
    }

    sgp30_InitAirQuality();

    __enable_irq();
    /* Infinite loop */
    while (1) {
        IWDG_feed();         // Feed watchdog

        rFlag &= ~(RFLAG_CO2 | RFLAG_TVCO | RFLAG_BASE_CO2 | RFLAG_BASE_TVCO | RFLAG_RAW_H2 |
                   RFLAG_RAW_ETHANOL);  // clear bits

        setBaselineCounter++;

        // According to datasheet, SGP30 baseline values need to be set at about 1 hour interval
        if (setBaselineCounter >= 3600U) {
            if (SGP30_SUCCESS != spg30_GetBaseLine(&sgp_data)) {
                rFlag &= (RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                debug_console("Error! spg30_GetBaseline failed!\n\r");
            } else {
                rFlag |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                debug_console("spg30_GetBaseline success!\n\r");
            }
            setBaselineCounter = 0;
            sgp30_SetBaseline(sgp_data.baselineCO2, sgp_data.baselineTVOC);
        }

        // According to datasheet, SGP30 MeasureAirQuality need to be called at about 1s interval in
        // order to work at maximum accuracy
        if (SGP30_SUCCESS != sgp30_MeasureAirQuality(&sgp_data)) {
            rFlag &= ~(RFLAG_CO2 | RFLAG_TVCO);
            debug_console("Error! spg30_MeasureAirQuality failed!\n\r");
        } else {
            rFlag |= (RFLAG_CO2 | RFLAG_TVCO);
            debug_console("spg30_MeasureAirQuality success!\n\r");
            snprintf(debug_msg, DBUG_MSG_LEN, "CO2eq:%uppm\n\r", sgp_data.CO2);
            debug_console(debug_msg);
            snprintf(debug_msg, DBUG_MSG_LEN, "TVOC:%uppb\n\r", sgp_data.TVOC);
            debug_console(debug_msg);
        }

        GPIOA->ODR ^= 0x20;  //  Blink led
        delay_ms(1000);
    }
    return 0;
}

/* Interrupt handlers here */

/**
 * \brief           DMA1 channel5 interrupt handler for USART1 RX
 */
void DMA1_Channel5_IRQHandler(void) {
    /* Check half-transfer complete interrupt */
    if (DMA1->ISR & DMA_ISR_HTIF5) {
        debug_console("USART1 DMA half-transfer interrupt!\r\n");
        DMA1->IFCR |= DMA_IFCR_CHTIF5; /*!< Channel 5 Half Transfer clear */
    }

    /* Check transfer-complete interrupt */
    if (DMA1->ISR & DMA_ISR_TCIF5) {
        debug_console("USART1 DMA transfer-complete interrupt!\r\n");
        u1tcFlag   = TRUE;
        DMA1->IFCR |= DMA_IFCR_CTCIF5; /*!< Channel 5 Transfer Complete clear */
        // rs485_send_data(usart1_rx_dma_buffer, USART1_RX_DMA_BUFFER_SIZE);
        modbusRtu_RunRequest(usart1_rx_dma_buffer, (void *)(&sgp_data));
        USART2_send_data(usart1_rx_dma_buffer, USART1_RX_DMA_BUFFER_SIZE);
        USART1_RX_Buffer_Reset();
        DMA1_Channel15_Reload();
    }
}

/**
 * \brief           USART1 global interrupt handler
 */
void USART1_IRQHandler(void) {
    uint32_t status = USART1->SR;
    uint8_t  data;
    /* Check for IDLE line interrupt */
    if (status & USART_SR_IDLE) {
        debug_console("USART1 Idle-line interrupt!\r\n");
        data = USART1->DR; /* Clear IDLE line flag */
        if (u1tcFlag == TRUE) {
            u1tcFlag = FALSE;
        } else {
            DMA1_Channel15_Reload();
            USART1_RX_Buffer_Reset();
        }
    }
}

/* Private functions */
/**
 * \brief Send debug information
 * \param[in] message - Debug message
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
void debug_console(const char *message) { debug_console(message); }

/**
 * \brief Local implementation for sending Modbus RTU data
 * \param[in] data - The address of the data to be sent
 * \param[in] data_length - The number of bytes
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
void modbusRtu_SendData(const uint8_t *const data, const size_t data_length) {
    rs485_send_data(data, data_length);
}

/**
 * \brief Local implementation for reading input register for Modbus RTU
 * \param[in] modbus_rtu_frame - Address + PDU + CRC, PDU = Function code + Data
 * \param[in] data - The address of the data to be sent, sgp30_t
 * \author siyuan xu, e2101066@edu.vamk.fi, Mar.2023
 */
MODBUS_RTU_ERR modbusRtu_ReadInputRegister(const uint8_t *const modbus_rtu_frame, void *data) {
    sgp30_t *sgp30_data    = (sgp30_t *)data;
    uint16_t register_addr = ((uint16_t)modbus_rtu_frame[START_ADDRESS_HI] << 8) |
                             (uint16_t)modbus_rtu_frame[START_ADDRESS_LOW];
    uint8_t        m_data[2];
    MODBUS_RTU_ERR err;

    err = modbusRtu_RegisterAddressValidation(register_addr);
    if (err != MODBUS_RTU_SUCCESS) {
        debug_console("BAD REGISTER ADDR:");
        return err;
    } else {
        switch (register_addr) {
            case REG_ADDR_CO2:
                if (rFlag & RFLAG_CO2) {
                    m_data[SGP30_MSB] = (sgp30_data->CO2 >> 8);
                    m_data[SGP30_LSB] = (sgp30_data->CO2 & 0xff);
                    modbusRtu_Reply(modbus_rtu_frame, m_data);
                    return MODBUS_RTU_SUCCESS;
                } else {
                    return MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                }
                break;
            case REG_ADDR_TVOC:
                if (rFlag & RFLAG_TVCO) {
                    m_data[SGP30_MSB] = (sgp30_data->TVOC >> 8);
                    m_data[SGP30_LSB] = (sgp30_data->TVOC & 0xff);
                    modbusRtu_Reply(modbus_rtu_frame, m_data);
                    return MODBUS_RTU_SUCCESS;
                } else {
                    return MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                }
                break;
            case REG_ADDR_BASE_CO2:
                if (rFlag & RFLAG_TVCO) {
                    m_data[SGP30_MSB] = (uint8_t)(sgp30_data->CO2 >> 8);
                    m_data[SGP30_LSB] = (uint8_t)(sgp30_data->CO2 & 0xff);
                    modbusRtu_Reply(modbus_rtu_frame, m_data);
                    MODBUS_RTU_SUCCESS;
                } else {
                    if (SGP30_SUCCESS != spg30_GetBaseLine(sgp30_data)) {
                        rFlag &= ~(RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                        debug_console("Error! spg30_GetBaseline failed!\n\r");
                        return MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                    } else {
                        m_data[SGP30_MSB] = (uint8_t)(sgp30_data->CO2 >> 8);
                        m_data[SGP30_LSB] = (uint8_t)(sgp30_data->CO2 & 0xff);
                        modbusRtu_Reply(modbus_rtu_frame, m_data);
                        rFlag |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                        debug_console("spg30_GetBaseline success!\n\r");
                        return MODBUS_RTU_SUCCESS;
                    }
                }
                break;
            case REG_ADDR_BASE_TVOC:
                if (rFlag & RFLAG_TVCO) {
                    m_data[SGP30_MSB] = (uint8_t)(sgp30_data->TVOC >> 8);
                    m_data[SGP30_LSB] = (uint8_t)(sgp30_data->TVOC & 0xff);
                    modbusRtu_Reply(modbus_rtu_frame, m_data);
                    return MODBUS_RTU_SUCCESS;
                } else {
                    if (SGP30_SUCCESS != spg30_GetBaseLine(sgp30_data)) {
                        rFlag &= ~(RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                        debug_console("Error! spg30_GetBaseline failed!\n\r");
                        return MODBUS_RTU_ERR_DATA_UNAVAILABLE;
                    } else {
                        m_data[SGP30_MSB] = (uint8_t)(sgp30_data->TVOC >> 8);
                        m_data[SGP30_LSB] = (uint8_t)(sgp30_data->TVOC & 0xff);
                        modbusRtu_Reply(modbus_rtu_frame, m_data);
                        rFlag |= (RFLAG_BASE_CO2 | RFLAG_BASE_TVCO);
                        debug_console("spg30_GetBaseline success!\n\r");
                        return MODBUS_RTU_SUCCESS;
                    }
                }
                break;
            case REG_ADDR_FEATURE_SET:
                break;
            case REG_ADDR_RAW_H2:
                break;
            case REG_ADDR_RAW_ETHANOL:
                break;
            case REG_ADDR_SERIAL_ID:
                break;
        }
    }
}
